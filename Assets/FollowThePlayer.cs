using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityStandardAssets.ImageEffects;

public class FollowThePlayer : MonoBehaviour {

    
    public float dampTime = 0.15f;
    private Vector3 velocity = Vector3.zero;
    public Transform target;
    public bool killTargetIfOffscreen = false;
    public bool mustBeOffscreenDownwardsToDie = true;
    public bool offscreenDownwardsIsRelative = false;
    public bool killBorder = true;
    public GameObject refPlayer;
    public float fallLatency;
    public bool isItTeetering;
    public bool isItVibrating;
    public int scrollH;
    public int scrollV;
    public float scrollLeftBound;
    public float scrollRightBound;
    public float scrollTopBound;
    public float scrollBottomBound;
    public float XOffset;
    public float YOffset;
    public bool followCameraBounds;
    public Vector4 cameraBounds;
    public float vibSpeed;
    public float vibDecay;
    public Shader shader;
    public bool lockedScriptsOnly;
    [Header("The following are distortions")]
    public float earthquakeEffect;
    public float erraticRotateEffect;
    public float sizeChangeEffect;
    public float pixelStretchEffect;
    [Header("Check the next ones to introduce new scrolling")]
    public bool perScreenScrolling;
    public bool originalScrolling;
    [Header("\"ritual scrolling\" only works if the edges kill")]
    public bool ritualScrollingUnlocked = false;
    public List<Vector2> ritualScrolling;
    public List<float> ritualScrollingSpeeds;
    public bool ritualScrollingVerticalOnly = false;
    public bool ritualVibrateOnStop = false;
    public float secondsItTakesForPSS;
    public bool horizontalPSS;
    public bool verticalPSS;
    public Vector4 perScreenBounds;
    public Vector2 perScreenPosition;
    public bool infinitepss;
    [HideInInspector]
    public bool helpWithLongFallingView = false;
    [HideInInspector]
    public Vector2 targetOffset = Vector2.zero;
    public bool monochromeForDramaticEffect = false;
    private bool tempdisablePSS;
    public Vector2 customScrollDistance = Vector2.zero;
    private Vector3 tempVibDisplace = Vector2.zero;
    private float orthoOriginal;
    public GameObject hiddenLayer;
    private List<Renderer> hiddenLayerCache;
    [HideInInspector]
    public TestScriptRotateScene rotateScene;

    public bool isFlipped;
    private Vector3 lastPos;
    public Vector2 autoGeneratedVelocity;

    private long frame = 0;
    //private double scaledFrameTime = 0f;

    private MeshRenderer pictureCube;
    //private Vector2 positionCorrection;
    private float excess1;
    [HideInInspector]
    public double specialTime1;

    private Camera cam;
    private SpecialWrapping wrapType;

    public const float piFourths = 0.78539816f;
    public const float piHalves = 1.5707963f;

    private Matrix4x4 originalProjection;

    public static FollowThePlayer main;

    private Vector3 fakeLocalPosition;
    private static Vector3 nextLocalPositionWhenCamExists;
    private static bool needToSetupWhenCamExists = false;

    [HideInInspector]
    public int stun = 0;

    public Coroutine WaitForRealSeconds(float time)
    {
        return StartCoroutine(WaitForRealSecondsImpl(time));
    }

    private IEnumerator WaitForRealSecondsImpl(float time)
    {
        double startTime = DoubleTime.UnscaledTimeRunning;
        while (DoubleTime.UnscaledTimeRunning - startTime < time)
            yield return 1;
    }

    public void SetTransformPosition(Vector3 pos)
    {
        transform.position = fakeLocalPosition = pos;
    }

    bool v2IsInfinity(Vector2 v)
    {
        return float.IsInfinity(v.x) && float.IsInfinity(v.y);
    }

    public bool PointIsOnScreen(Vector3 p)
    {
        return Mathf.Abs(p.x - transform.position.x) <= 160f && Mathf.Abs(p.y - transform.position.y) <= 108f;
    }

    private void Awake()
    {
        frame = 0;
        //scaledFrameTime = 0f;
        excess1 = 0f;
        main = this;
        if (needToSetupWhenCamExists)
        {
            fakeLocalPosition = nextLocalPositionWhenCamExists;
            transform.position = nextLocalPositionWhenCamExists;
            needToSetupWhenCamExists = false;
        }
    }

    private void OnDestroy()
    {
        main = null;
    }

    void Start()
    {
        cam = GetComponent<Camera>();
        originalProjection = cam.projectionMatrix;
        dampTime = 0.25f;
        lockedScriptsOnly = false;
        orthoOriginal = GetComponent<Camera>().orthographicSize;
        tempdisablePSS = false;
        //StartCoroutine(Succ());
        fakeLocalPosition = lastPos = transform.localPosition;
        autoGeneratedVelocity = Vector2.zero;
        pictureCube = GameObject.FindGameObjectWithTag("PictCube").GetComponent<MeshRenderer>();
        rotateScene = FindObjectOfType<TestScriptRotateScene>();
        wrapType = GetComponent<SpecialWrapping>();
        //positionCorrection = Vector2.zero;
    }

    IEnumerator Succ()
    {
        while (true)
        {
            float fl = 1f;
            if (isFlipped)
            {
                fl = -1f;
            }
            if (target && !lockedScriptsOnly)
            {
                float xP = target.position.x * scrollH + XOffset;
                float yP = target.position.y * scrollV + YOffset;

                if (followCameraBounds)
                {
                    xP = Mathf.Max(Mathf.Min(xP, cameraBounds.z), cameraBounds.x);
                    yP = Mathf.Max(Mathf.Min(yP, fl*cameraBounds.w), fl*cameraBounds.y);
                }

                Vector3 vecP = new Vector3(xP, yP, target.position.z);

                Vector3 point = cam.WorldToViewportPoint(vecP);
                Vector3 delta = vecP - cam.ViewportToWorldPoint(new Vector3(0.5f, 0.5f, point.z)); //(new Vector3(0.5, 0.5, point.z));
                Vector3 destination = fakeLocalPosition + delta;
                fakeLocalPosition = Vector3.Lerp(fakeLocalPosition, destination, dampTime / 1.65f);
                Vector2 roundedPos = new Vector2(Mathf.Round(fakeLocalPosition.x), Mathf.Round(fakeLocalPosition.y));
                transform.localPosition = new Vector3(roundedPos.x, roundedPos.y, fakeLocalPosition.z);
            }
            if (isItTeetering)
            {
                transform.rotation = Quaternion.AngleAxis(8 * (float)System.Math.Sin(1.5f * DoubleTime.ScaledTimeRunning), Vector3.forward);
            }
            if (isItVibrating)
            {
                Vector3 xx = Fakerand.UnitSphere();
                fakeLocalPosition = fakeLocalPosition + new Vector3(vibSpeed * xx.x, vibSpeed * xx.y, 0);
                Vector2 roundedPos = new Vector2(Mathf.Round(fakeLocalPosition.x), Mathf.Round(fakeLocalPosition.y));
                transform.localPosition = new Vector3(roundedPos.x, roundedPos.y, fakeLocalPosition.z);
                vibSpeed = Mathf.Lerp(0, vibSpeed, 1 - vibDecay);
            }
            yield return new WaitForEndOfFrame();
        }
    }

    public bool scrollingIndicator = false;

    IEnumerator Scroll(Vector2 dir)
    {
        if (KHealth.someoneDied || Door1.levelComplete)
        {
            yield break;
        }
        scrollingIndicator = true;
        GetComponent<AudioSource>().Play();
        int xx = (int)dir.x;
        int yy = (int)dir.y;
        if ((perScreenBounds.magnitude != 0 || infinitepss) && !tempdisablePSS)
        {
            if ((perScreenPosition.x + xx >= perScreenBounds.x && perScreenPosition.x + xx <= perScreenBounds.z && perScreenPosition.y + yy >= perScreenBounds.y && perScreenPosition.y + yy <= perScreenBounds.w) || infinitepss)
            {
                tempdisablePSS = true;
                float d = 0.01666666f;
                Utilities.canPauseGame = false;
                Utilities.canUseInventory = false;
                float t = Time.timeScale;
                if (t == 0f)
                {
                    //print("SOFTLOCK PREVENTION?");
                    t = 1f;
                }
                Time.timeScale = 0;
                float xmuch = (customScrollDistance.x != 0f) ? customScrollDistance.x : 320f;
                float ymuch = (customScrollDistance.y != 0f) ? customScrollDistance.y : 216f;
                Vector2 v = new Vector2(transform.position.x + dir.x * xmuch, transform.position.y + dir.y * ymuch);
                double startTime = DoubleTime.UnscaledTimeRunning;
                while (Fastmath.FastV2Dist(transform.position, v) > 400f * d)
                {
                    Time.timeScale = 0;
                    transform.position += (new Vector3(dir.x * xmuch, dir.y * ymuch) * d) / secondsItTakesForPSS;
                    fakeLocalPosition = transform.localPosition;
                    yield return new WaitForEndOfFrame();
                    if (dir.x == 0f && dir.y == 0f)
                    {
                        transform.position = v;
                    }
                }
                transform.position = v;
                fakeLocalPosition = transform.localPosition;
                Time.timeScale = t;
                Utilities.canPauseGame = true;
                Utilities.canUseInventory = true;
                tempdisablePSS = false;

                if (rotateScene) {
                    float c = Mathf.Cos(rotateScene.goalRotation * Mathf.Deg2Rad);
                    float s = Mathf.Sin(rotateScene.goalRotation * Mathf.Deg2Rad);
                    dir = new Vector2(c*dir.x - s*dir.y, s*dir.x + c*dir.y);
                }
                perScreenPosition += dir;
                perScreenPosition = new Vector2(Mathf.Round(perScreenPosition.x), Mathf.Round(perScreenPosition.y));
            }
        }
        GetComponent<AudioSource>().Stop();
        scrollingIndicator = false;
        yield return new WaitForEndOfFrame();
        //tempdisablePSS = false; // This line will cause a softlock when the player is out of screen diagonally.
    }

    public void MoveTowardsByScreen(Vector3 nextPosition)
    {
        nextPosition -= transform.position;
        Vector2 roundSize = new Vector2(320f, 216f);
        if (customScrollDistance != Vector2.zero) { roundSize = customScrollDistance; }
        nextPosition = new Vector3(Mathf.Round(nextPosition.x / roundSize.x) * roundSize.x,
                                   Mathf.Round(nextPosition.y / roundSize.y) * roundSize.y,
                                   nextPosition.z);
        nextPosition += transform.position; // by now nextPosition is where we want

        Vector3 finalDifference = nextPosition - transform.position;

        perScreenPosition += new Vector2(finalDifference.x / roundSize.x, finalDifference.y / roundSize.y);
        transform.position = nextPosition;
        fakeLocalPosition = transform.localPosition;
    }

    public bool WouldItScrollIfIWereHere(Vector3 newPos, out Vector3 wrappedPos)
    {
        Vector3 targPos = new Vector3(Mathf.Round(newPos.x), Mathf.Round(newPos.y), newPos.z);
        //Vector2 dist = targPos - transform.position;

        if (GetComponent<SpecialWrapping>() != null)
        {
            SpecialWrapping sw = GetComponent<SpecialWrapping>();
            if (sw.horizontal) {
                float dir = Mathf.Sign(targPos.x - transform.position.x);
                if (Mathf.Abs(targPos.x - transform.position.x) > 160f)
                {
                    targPos -= dir * 320f * Vector3.right;
                }
            }
            if (sw.vertical)
            {
                float dir = Mathf.Sign(targPos.y - transform.position.y);
                if (Mathf.Abs(targPos.y - transform.position.y) > 108f)
                {
                    targPos -= dir * 216f * Vector3.up;
                }
            }
        }

        wrappedPos = targPos;

        return (System.Math.Abs(transform.position.y - targPos.y + 19f) > 110f) || (System.Math.Abs(transform.position.x - targPos.x) > 162f);
        // horizontal should be 166 but 162 is to be safe
    }

    public bool WouldItScrollIfIWereHere(Vector3 newPos)
    {
        Vector3 throwAway;
        return WouldItScrollIfIWereHere(newPos, out throwAway);
    }

    void CullSearch(Transform t)
    {
        if (t == null) { return; }
        bool prevActive = t.gameObject.activeSelf;
        t.gameObject.SetActive(true);
        if (t.GetComponent<Renderer>()) { hiddenLayerCache.Add(t.GetComponent<Renderer>()); }
        foreach (Transform tc in t) { if (tc != t) { CullSearch(tc); } }
        t.gameObject.SetActive(prevActive);
    }

    private bool fogEnabled; 

    private void OnPreCull()
    {
        /*GetComponent<Camera>().cullingMatrix = Matrix4x4.Ortho(-200, 200, -136, 136, -1000, 3000) *
                                               Matrix4x4.Translate(Vector3.zero) *
                                               GetComponent<Camera>().worldToCameraMatrix;*/
        fogEnabled = RenderSettings.fog;
        RenderSettings.fog = false;

        if (hiddenLayer == null) { return; }
        if (hiddenLayerCache == null)
        {
            hiddenLayerCache = new List<Renderer>();
            CullSearch(hiddenLayer.transform);
        }

        for (int i = 0; i < hiddenLayerCache.Count; ++i)
        {
            if (hiddenLayerCache[i])
            {
                hiddenLayerCache[i].enabled = false;
            }
        }

        if (target && target.GetComponent<SpriteRenderer>())
        {
            SpriteRenderer s = target.GetComponent<SpriteRenderer>();
            s.material.SetFloat("_BW", 0f);
            s.flipX = !s.flipX;
        }
    }

    private void OnPostRender()
    {
        RenderSettings.fog = fogEnabled;
        if (hiddenLayer == null || hiddenLayerCache == null) { return; }

        for (int i = 0; i < hiddenLayerCache.Count; ++i)
        {
            if (hiddenLayerCache[i])
            {
                hiddenLayerCache[i].enabled = true;
            }
        }

        if (target && target.GetComponent<SpriteRenderer>())
        {
            SpriteRenderer s = target.GetComponent<SpriteRenderer>();
            s.material.SetFloat("_BW", 1f);
            s.flipX = !s.flipX;
        }
    }

    void Update()
    {
        if (stun > 0) { --stun; return; }

        if (target && target.GetComponent<BasicMove>() && !perScreenScrolling)
        {
            transform.eulerAngles = target.eulerAngles;
            
            /*if (target.lossyScale != Vector3.one)
            {
                Matrix4x4 p = originalProjection;
                p.m00 = 1f / (target.lossyScale.x * 160f);
                p.m11 = 1f / (target.lossyScale.y * 108f);
                cam.projectionMatrix = p;
            }
            else
            {
                cam.projectionMatrix = originalProjection;
            }*/
            
        }

        ColorCorrectionCurves scd = GetComponent<ColorCorrectionCurves>();
        if (scd != null)
        {
            if (monochromeForDramaticEffect)
            {
                scd.saturation = 0f;
            }
            else
            {
                scd.saturation = (Time.timeScale == 0) ? scd.saturation : Time.timeScale;
            }
        }
        frame++;
        //print(positionCorrection);
        //fakeLocalPosition += (Vector3)positionCorrection;
        //print(fakeLocalPosition);
        float fl = 1f;
        if (isFlipped)
        {
            fl = -1f;
        }
        if (target && enabled)
        {
            Vector3 targPos = new Vector3(Mathf.Round(target.position.x), Mathf.Round(target.position.y), target.position.z);
            if (helpWithLongFallingView && target.GetComponent<Rigidbody2D>())
            {
                Rigidbody2D tr2 = target.GetComponent<Rigidbody2D>();
                BasicMove tbm = target.GetComponent<BasicMove>();
                bool grounded = tbm && tbm.grounded > 0;
                Vector3 oldTargPos = targPos;
                if (Vector2.Dot(-target.transform.up, tr2.velocity.normalized) > 0.1f && !grounded)
                {
                    targPos -= target.transform.up * Mathf.Clamp(Vector2.Dot(-target.transform.up, tr2.velocity) * 0.25f, 0f, 96f);
                    targPos = new Vector3(Mathf.Round(targPos.x), Mathf.Round(targPos.y), targPos.z);
                    if (WouldItScrollIfIWereHere(targPos))
                    {
                        targPos = oldTargPos;
                    }
                }
            }
            if (targetOffset.sqrMagnitude > 1f && target.gameObject.layer == 20)
            {
                if (!WouldItScrollIfIWereHere(targPos))
                {
                    Vector3 oldTargPos = targPos;
                    targPos += (Vector3)targetOffset;
                    targPos = new Vector3(Mathf.Round(targPos.x), Mathf.Round(targPos.y), targPos.z);
                    if (WouldItScrollIfIWereHere(targPos))
                    {
                        //try to clamp it in one dimension
                        Vector2 targPosX = new Vector2(oldTargPos.x, targPos.y);
                        Vector2 targPosY = new Vector2(targPos.x, oldTargPos.y);
                        if (!WouldItScrollIfIWereHere(targPosX)) { targPos = targPosX; }
                        else if (!WouldItScrollIfIWereHere(targPosY)) { targPos = targPosY; }
                        else { targPos = oldTargPos; }
                    }
                }
            }

            if (originalScrolling && !tempdisablePSS)
            {
                float xP = targPos.x * scrollH + XOffset;
                float yP = targPos.y * scrollV + YOffset;

                if (followCameraBounds)
                {
                    xP = Mathf.Max(Mathf.Min(xP, cameraBounds.z), cameraBounds.x);
                    yP = Mathf.Max(Mathf.Min(yP, fl * cameraBounds.w), fl * cameraBounds.y);
                }

                Vector3 vecP = new Vector3(xP, yP, targPos.z);

                Vector3 point = cam.WorldToViewportPoint(vecP);
                Vector3 delta = vecP - cam.ViewportToWorldPoint(new Vector3(0.5f, 0.5f, point.z)); //(new Vector3(0.5, 0.5, point.z));
                Vector3 destination = fakeLocalPosition + delta /*+ ((Vector3)refPlayer.GetComponent<Rigidbody2D>().velocity / 14)*/ + new Vector3(earthquakeEffect * (Mathf.PerlinNoise((float)DoubleTime.ScaledTimeRunning, (float)DoubleTime.UnscaledTimeRunning) - 0.5f), earthquakeEffect * (Mathf.PerlinNoise((float)DoubleTime.UnscaledTimeRunning, (float)DoubleTime.ScaledTimeRunning) - 0.5f), 0);

                transform.eulerAngles = transform.eulerAngles + new Vector3(0, 0, erraticRotateEffect * (Mathf.PerlinNoise((float)DoubleTime.UnscaledTimeRunning, 1.0f - (float)DoubleTime.UnscaledTimeRunning) - 0.5f));
                cam.orthographicSize = Mathf.Clamp(orthoOriginal + ((sizeChangeEffect * (Mathf.PerlinNoise(666f, (float)DoubleTime.UnscaledTimeRunning))) - (sizeChangeEffect / 2)), 60f, 240f);
                float cool = 1.0f + (pixelStretchEffect * (Mathf.PerlinNoise(6.66f, (float)DoubleTime.UnscaledTimeRunning) - (pixelStretchEffect / 2)));
                Vector2 v34 = new Vector2(Mathf.Clamp(1.0f / cool, 0.25f, 1.0f), Mathf.Clamp(cool, 0.25f, 1.0f));
                cam.rect = new Rect(Vector2.zero, v34);

                if (followCameraBounds)
                {
                    float tempX; float tempY;
                    tempX = Mathf.Max(Mathf.Min(destination.x, cameraBounds.z), cameraBounds.x);
                    tempY = Mathf.Max(Mathf.Min(destination.y, cameraBounds.w), cameraBounds.y);
                    destination = new Vector3(tempX, tempY, destination.z);
                }
                fakeLocalPosition = Vector3.Lerp(fakeLocalPosition, destination, dampTime / 1.65f);
            }
            if (perScreenScrolling)
            {
                if (!tempdisablePSS)
                {
                    Vector2 dist = targPos - transform.position;
                    if (System.Math.Abs(transform.position.y - targPos.y + 19f) > 110f && verticalPSS && !tempdisablePSS
                        && !(wrapType && (wrapType.vertical || wrapType.verticalTwist)))
                    {
                        StartCoroutine(Scroll(Vector2.up * Mathf.Sign(dist.y)));
                    }
                    
                    if (System.Math.Abs(transform.position.x - targPos.x) > 166f && horizontalPSS && !tempdisablePSS
                        && !(wrapType && (wrapType.horizontal || wrapType.horizontalTwist)))
                    {
                        StartCoroutine(Scroll(Vector2.right * Mathf.Sign(dist.x)));
                    }
                }

                if (!originalScrolling)
                {
                    transform.eulerAngles = transform.eulerAngles + new Vector3(0, 0, erraticRotateEffect * (Mathf.PerlinNoise((float)DoubleTime.UnscaledTimeRunning, 1.0f - (float)DoubleTime.UnscaledTimeRunning) - 0.5f));
                    cam.orthographicSize = Mathf.Clamp(orthoOriginal + ((sizeChangeEffect * (Mathf.PerlinNoise(666f, (float)DoubleTime.UnscaledTimeRunning))) - (sizeChangeEffect / 2)), 60f, 240f);
                    float cool = 1.0f + (pixelStretchEffect * (Mathf.PerlinNoise(6.66f, (float)DoubleTime.UnscaledTimeRunning) - (pixelStretchEffect / 2)));
                    Vector2 v34 = new Vector2(Mathf.Clamp(1.0f / cool, 0.25f, 1.0f), Mathf.Clamp(cool, 0.25f, 1.0f));
                    cam.rect = new Rect(Vector2.zero, v34);
                    fakeLocalPosition += new Vector3(earthquakeEffect * (Mathf.PerlinNoise((float)DoubleTime.ScaledTimeRunning, (float)DoubleTime.UnscaledTimeRunning) - 0.5f), earthquakeEffect * (Mathf.PerlinNoise((float)DoubleTime.UnscaledTimeRunning, (float)DoubleTime.ScaledTimeRunning) - 0.5f), 0);
                }
            }
        }
        if (isItTeetering)
        {
            transform.rotation = Quaternion.AngleAxis(8 * (float)System.Math.Sin(1.5f * DoubleTime.ScaledTimeRunning), Vector3.forward);
        }
        if (isItVibrating)
        {
            Vector3 xx = Fakerand.UnitSphere();
            fakeLocalPosition -= tempVibDisplace;
            tempVibDisplace = new Vector3(vibSpeed * xx.x, vibSpeed * xx.y, 0);
            fakeLocalPosition += tempVibDisplace;
            vibSpeed = Mathf.Lerp(0, vibSpeed, 1 - vibDecay);
        }

        if (killTargetIfOffscreen)
        {
            if (pictureCube && killBorder)
            {
                pictureCube.material.SetFloat("_BlackBorder", 0.03f);
            }

            if (target && target.GetComponent<KHealth>())
            {
                if (ritualScrollingUnlocked && ritualScrolling.Count > 0 && ritualScrollingSpeeds.Count > 0)
                {
                    //print(DoubleTime.ScaledTimeSinceLoad - specialTime1);
                    if ((ritualScrollingVerticalOnly? (fakeLocalPosition.y == ritualScrolling[0].y) : ((Vector2)fakeLocalPosition == ritualScrolling[0]))
                        || (v2IsInfinity(ritualScrolling[0]) && DoubleTime.ScaledTimeSinceLoad-specialTime1 >= ritualScrollingSpeeds[0]))
                    {
                        ritualScrolling.RemoveAt(0);
                        ritualScrollingSpeeds.RemoveAt(0);
                        if (ritualScrolling.Count > 0 && v2IsInfinity(ritualScrolling[0]))
                        {
                            if (ritualVibrateOnStop)
                            {
                                vibSpeed += 1.5f;
                                //play sound effect maybe?
                            }
                            specialTime1 = DoubleTime.ScaledTimeSinceLoad;
                        }
                    }
                    else if (!v2IsInfinity(ritualScrolling[0]))
                    {
                        //print(ritualScrollingSpeeds[0] * Time.timeScale);
                        float scrollAmt = ritualScrollingSpeeds[0] * Time.timeScale;
                        if (!ritualScrollingVerticalOnly)
                        {
                            scrollAmt /= Mathf.Cos(Mathf.Repeat(Mathf.Atan2(ritualScrolling[0].y, ritualScrolling[0].x) + piFourths, piHalves) - piFourths);
                        }
                        float frac = scrollAmt - Mathf.Floor(scrollAmt);
                        excess1 += frac;
                        float extraUnit = 0f;
                        while (excess1 >= 1f)
                        {
                            excess1 -= 1f;
                            extraUnit += 1f;
                        }
                        Vector2 ritTargpos = (ritualScrollingVerticalOnly)?(new Vector2(fakeLocalPosition.x,ritualScrolling[0].y)) :ritualScrolling[0];
                        Vector2 np = Vector2.MoveTowards(fakeLocalPosition, ritTargpos, Mathf.Floor(scrollAmt) + extraUnit);
                        fakeLocalPosition = new Vector3(np.x, np.y, fakeLocalPosition.z);
                        if (ritualScrollingVerticalOnly)
                        {
                            cameraBounds.y = cameraBounds.w = np.y;
                        }
                    }
                }

                bool downwards = false;
                if (!offscreenDownwardsIsRelative)
                {
                    downwards = (target.position.y - transform.position.y < -136f) && (!originalScrolling || Mathf.Abs(transform.position.y - cameraBounds.y) < 8f);
                }
                else
                {
                    downwards = transform.InverseTransformPoint(target.position).y < -136f;
                }
                bool offCheck = mustBeOffscreenDownwardsToDie
                    ? downwards
                    :(!target.GetComponent<Renderer>().isVisible);
                if (offCheck && frame > 10)
                {
                    if (mustBeOffscreenDownwardsToDie)
                    {
                        target.GetComponent<KHealth>().ChangeHealth(Mathf.NegativeInfinity, "below boundary");
                    }
                    else
                    {
                        target.GetComponent<KHealth>().ChangeHealth(Mathf.NegativeInfinity, "out of picture");
                    }
                }
            }
        }
        else
        {
            if (pictureCube)
            {
                pictureCube.material.SetFloat("_BlackBorder", 0f);
            }
        }

        Vector2 roundedPos = new Vector2(Mathf.Round(fakeLocalPosition.x), Mathf.Round(fakeLocalPosition.y));
        //positionCorrection = new Vector2(roundedPos.x - transform.localPosition.x, roundedPos.y - transform.localPosition.y);
        transform.localPosition = new Vector3(roundedPos.x, roundedPos.y, fakeLocalPosition.z);
        autoGeneratedVelocity = (fakeLocalPosition - lastPos);
        lastPos = fakeLocalPosition;
        //scaledFrameTime += Time.timeScale;
    }

    public static void SetCameraPosition(Vector3 newPos)
    {
        if (main)
        {
            main.fakeLocalPosition = newPos;
            main.transform.position = newPos;
        }
        else
        {
            nextLocalPositionWhenCamExists = newPos;
            needToSetupWhenCamExists = true;
        }
    }

}
